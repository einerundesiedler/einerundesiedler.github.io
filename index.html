<meta charset="UTF-8"> 
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
<head>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.50.0/dist/phaser.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.2.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.2.1/firebase-database.js"></script>

<style>
    
	body {	
		margin: 0;
		padding: 0;
		background-color: #f1f1f1;
	}
</style>
</head>
<body>
<script>RELEASE=true;</script>
<script>VERSION="12/28/2020, 01:04:12";</script>

<script>
function array_remove_duplicates(value, index, self) {
  return self.indexOf(value) === index;
}

function shuffle_array(array) {
    var currentIndex = array.length, temporaryValue, randomIndex;
  
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
  
      // Pick a remaining element...
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex -= 1;
  
      // And swap it with the current element.
      temporaryValue = array[currentIndex];
      array[currentIndex] = array[randomIndex];
      array[randomIndex] = temporaryValue;
    }
  
    return array;
  }
</script>
<script>
class DB {
    constructor() {
        // firebase config 
        var firebaseConfig = {
            apiKey: "AIzaSyCsKZy0uardEJ9ptCUnWPiPBZPusp7aXy4",
            authDomain: "einerundesiedler-50542.firebaseapp.com",
            databaseURL: "https://einerundesiedler-50542-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "einerundesiedler-50542",
            storageBucket: "einerundesiedler-50542.appspot.com",
            messagingSenderId: "1037179221686",
            appId: "1:1037179221686:web:1b86c4acf11eac025c1817"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);

        // get realtime database references
        this.refCards = firebase.database().ref().child('cards');
        this.refDecks = firebase.database().ref().child('decks');

    }    

    // serialize card data with initial position
    reset_card_positions(cards) {
        var data = {};
        for (var i = 0; i < cards.length; i++) {
            data[String(i)] = {
                x: Card.start_x,
                y: Card.start_y,
                r: 0
            };
        }
        
        // upload to database
        this.refCards.set(data);
    }
    
    // upload new card position to database
    set_card_position(card_index, x, y, angle) {
        this.refCards.child(String(card_index)).set({x: x, y:y, r:angle});
    }

    // creates individual listener for each card position
    link_card_positions(gameLoop) {
        gameLoop.cards.forEach(card => {
            this.refCards.child(String(card.index)).on('value', (snapshot) => {
                var pos = snapshot.val();
                gameLoop.cards[card.index].on_pos_update_in_database(pos.x, pos.y, pos.r);
            });
        });
    }

    
    // upload new card position to database
    set_deck_data(deck_index, cards) {
        this.refDecks.child(String(deck_index)).set(cards);
    }

    link_decks(gameLoop) {
        gameLoop.decks.forEach(deck => {
            this.refDecks.child(String(deck.index)).on('value', (snapshot) => {
                var cards = snapshot.val();
                gameLoop.decks[deck.index].set_cards(cards);
            });
        });
    }

}


</script>
<script>
class Button {
    constructor(scene, x, y, text, onClick) {

        this.bg = scene.add.image(x, y, 'button').setInteractive();
        this.bg.on('pointerup', onClick);

        this.textfield = scene.add.text(x-60, y, text, { fontSize: '24px', fill: '#000' });
    }

    set text(val) {
        this.textfield.text = val;
    }
}
</script>
<script>

class Card{
    static hasDragListener = false;
    static start_x = -200;
    static start_y = -200;


    constructor(scene, card_data, index) {
        // short index for realtime database connection to save bandwidth 
        this.index = index;
        this.data = card_data;
        this.scene = scene;

        // ui components
        this.image = scene.add.image(Card.start_x, Card.start_y, card_data.src).setInteractive();
        this.image.setScale(0.33);
        
        this.pointerdowntime = 0;
        this.image.on('pointerdown', () => this.onPointerDown()); 
        this.image.on('pointerup', () => this.onPointerUp()); 

        // parent view pointer for drag listener resolving 
        this.image.view = this; 

        // set drag listeners only once
        scene.input.setDraggable(this.image);
        if (!Card.hasDragListener) {
            Card.hasDragListener = true;
            scene.input.on('drag',  (pointer, gameObject, dragX, dragY) => { gameObject.view.onDrag(dragX, dragY); });
            scene.input.on('dragend', (pointer, gameObject) => { gameObject.view.onDragEnd(); });
        }
    }

    resetPosition() {
        this.image.x = Card.start_x;
        this.image.y = Card.start_y;
        this.sync();
    }

    moveTo(x, y, sync) {
        this.image.x = x;
        this.image.y = y;

        if (sync == true) {
            this.sync();
        }
    }

    rotate(angle, sync) {
        this.image.angle = angle;
        
        if (sync == true) {
            this.sync();
        }
    }

    onPointerDown() {
        this.scene.main.onPointerDownCard(this);
        this.pointerdowntime = Date.now();
    }

    onPointerUp() {
        if (Date.now() - this.pointerdowntime < 250) {
            this.rotate(this.image.angle + 90, true);
        }
    }

    onDrag(dragX, dragY) {
        this.moveTo(dragX, dragY);
    }

    onDragEnd() {
        this.sync();
    }

    sync() {
        this.scene.db.set_card_position(this.index, this.image.x, this.image.y, this.image.angle);
    }

    on_pos_update_in_database(x, y, angle) {
        this.moveTo(x, y);
        this.rotate(angle);
    }
}


// creates card views and stores it in gameloop.cards
// links position to database
function create_cards_from_json(scene, json) {
    for(var i = 0; i < json.cards.length; i++) {
        var data = json.cards[i];
        var card = new Card(scene, data, i);

        // store in gameloop
        scene.main.cards.push(card);
    }

    // syncronize card position
    scene.db.link_card_positions(scene.main);
}
</script>
<script>


class CardDeck {
    constructor(scene, index, card_type, x, y)  {
        this.index = index;
        this.cards = [];
        this.card_type = card_type;
        this.add_to_scene(scene, x, y);
        this.hover = false;

        this.lastpointerdown = 0;
    }

    get card_back() {
        switch (this.card_type) {
            case "EVENT":
                return "back_event.png"
            case "CITY":
                return "back_city.png"
            case "ROAD":
                return "back_road.png"
            case "VILLAGE":
                return "back_village.png"
            case "ENVIRONMENT":
                return "back_environment.png"
            case "EXTENSION":
                return "back_extension.png"
        }
    }

    add_to_scene(scene, x, y) {
        this.scene = scene;
        this.obj = scene.add.image(x, y, this.card_back).setInteractive();
        this.textfield = scene.add.text(x-60, y-10, "", { fontSize: '22px', fill: '#fff' });

        this.obj.setScale(0.5);
        
        this.obj.on('pointerdown', () => this.scene.main.onPointerDownDeck(this)); 
        this.obj.on('pointerup', () => this.scene.main.onPointerUpDeck(this)); 
        this.obj.on('pointerover', () => this.onPointerOver()); 
        this.obj.on('pointerout', () => this.onPointerOut()); 
    }

    onPointerOver() {
        this.hover = true;
        this.update();
    }

    onPointerOut() {
        this.hover = false;
        this.update();
    }

    update() {
        if (this.hover) {
            this.obj.setTint(0x555555);
        } else {
            this.obj.clearTint();
        }

        this.textfield.text = this.hover ? this.num_cards + " Karten" : "";
    }
    
    get num_cards() {
        return this.cards == undefined ? 0 : this.cards.length;
    }


    // set either by array of cards or card_indices
    set_cards(cards) {
        if (cards == null) { return }

        if (cards.length == 0) {
            this.cards = [];
        } else {
            this.cards = cards[0].index == undefined ? cards : cards.map(card => card.index);
        }

        this.update();
    }

    add_card(card_id) {
        this.cards.push(card_id);
        this.sync();
    }

    remove_card(id) {
        this.cards = this.cards.filter(card_id => card_id != id);
        this.sync();
    }

    shuffle() {   
        this.cards = shuffle_array(this.cards);
        this.sync();
    }

    draw_card() {
        var card = this.cards.pop();
        this.update();
        this.sync();
        return card;
    }

    sync() {
        this.scene.db.set_deck_data(this.index, this.cards);
    }
}

// call during scene.preload()
// loads all card images from json asset list
function load_card_images(scene, json) {
    var urls = json.cards.map(card => card.src).filter(array_remove_duplicates);
    urls = json.card_backs.concat(urls);

    urls.forEach(url => {
        scene.load.image(url, ASSET_PATH + "cards/" + url);
    });

}

function create_decks(scene) {
    var y_start = 450;

    scene.main.decks.push(new CardDeck(scene, 0, "EVENT", 100, y_start));
    scene.main.decks.push(new CardDeck(scene, 1, "CITY", 250, y_start));
    scene.main.decks.push(new CardDeck(scene, 2, "ROAD", 400, y_start));
    scene.main.decks.push(new CardDeck(scene, 3, "VILLAGE", 550, y_start));
    scene.main.decks.push(new CardDeck(scene, 4, "ENVIRONMENT", 700, y_start));

    for(var i = 0; i < 5; i++) {
        scene.main.decks.push(new CardDeck(scene, 5+i, "EXTENSION", 850 + i * 150, y_start));
    }
    
    scene.db.link_decks(scene.main);
}

function reset_decks(decks, cards) {
    decks[0].set_cards(cards.filter(card => card.data.type == "EVENT"));
    decks[1].set_cards(cards.filter(card => card.data.type == "CITY"));
    decks[2].set_cards(cards.filter(card => card.data.type == "ROAD"));
    decks[3].set_cards(cards.filter(card => card.data.type == "VILLAGE"));
    decks[4].set_cards(cards.filter(card => card.data.type == "ENVIRONMENT"));

    var card_extensions = shuffle_array(cards.filter(card => card.data.type == "EXTENSION"));
    var num_cards = Math.ceil(card_extensions.length / 5);

    for(var i = 0; i < 5; i++) {
        var cards = card_extensions.slice(i*num_cards, Math.min((i+1)*num_cards, card_extensions.length));
        decks[5+i].set_cards(cards);
    }

    decks.forEach(deck => deck.shuffle());
}
</script>
<script>
ASSET_PATH = !RELEASE ? "assets/" : "https://raw.githubusercontent.com/einerundesiedler/einerundesiedler.github.io/master/assets/";

var config = {
    type: Phaser.AUTO,
    width: 1920,
    height: 1080,
    backgroundColor: "#ffb",
    scene: {
        preload: preload,
        create: create,
        update: update,
        render: render
    }
};

var game = new Phaser.Game(config);

function preload ()
{
    this.db = new DB();

    this.load.once('load', (fileObj) => onLoaded(this, fileObj));
    this.load.json('cardlist', ASSET_PATH+'cardlist.json');

    this.load.image('button', ASSET_PATH+"ui/button.png");
}

function onLoaded(scene, fileObj) {
    
    switch(fileObj.key) {
        case "cardlist":
            load_card_images(scene, JSON.parse(fileObj.xhrLoader.response));
            break;
    } 
}


function create ()
{
    this.add.text(2, 2, 'version: ' + VERSION, { fontSize: '12px', fill: '#000' });

    // ------------------- GAME LOOP ----------------
    this.main = new GameLoop(this);
    
    // creates cards and links to database
    create_cards_from_json(this, this.cache.json.get('cardlist'));

    // create empty decks and link to database
    create_decks(this);
    



    // ------------------- UI ----------------
    this.ui = {};
    this.ui.btn_newgame = new Button(this, 650, 20, "new game", () => this.main.onNewGameClick());
    this.ui.btn_player = new Button(this, 800, 20, "join", () => this.main.onPlayerButtonClick());


}

function update ()
{
}


function render () 
{

}




class GameLoop {
    constructor(scene)  {
        this.scene = scene;
        this.playerID = 0;

        this.cards = [];
        this.decks = [];

        this.pointer_down_deck = undefined;
        this.pointer_down_card = undefined;
    }

    onNewGameClick() {
        // create card data from 
        reset_decks(this.decks, this.cards);
        this.scene.db.reset_card_positions(this.cards);

        // --- RED SETUP
        this.getCardById("env_coal_red").moveTo(500, 120, true);
        this.getCardById("village_red_1").moveTo(600, 220, true);
        this.getCardById("env_brick_red").moveTo(500, 320, true);
        
        this.getCardById("env_gold_red").moveTo(700, 120, true);
        this.getCardById("road_red").moveTo(700, 220, true);
        this.getCardById("env_wheat_red").moveTo(700, 320, true);
        
        this.getCardById("env_wood_red").moveTo(900, 120, true);
        this.getCardById("village_red_2").moveTo(800, 220, true);
        this.getCardById("env_sheep_red").moveTo(900, 320, true);

        // --- BLACK SETUP
        this.getCardById("env_coal_black").moveTo(500, 580, true);
        this.getCardById("village_black_1").moveTo(600, 680, true);
        this.getCardById("env_brick_black").moveTo(500, 780, true);
        
        this.getCardById("env_gold_black").moveTo(700, 580, true);
        this.getCardById("road_black").moveTo(700, 680, true);
        this.getCardById("env_wheat_black").moveTo(700, 780, true);
        
        this.getCardById("env_wood_black").moveTo(900, 580, true);
        this.getCardById("village_black_2").moveTo(800, 680, true);
        this.getCardById("env_sheep_black").moveTo(900, 780, true);
    }

    onPlayerButtonClick() {
        this.playerID = this.playerID == 1 ? 2 : 1;
        this.scene.ui.btn_player.text = "player: " + this.playerID;
    }

    onPointerDownCard(card) {
        this.pointer_down_card = card;
        this.pointer_down_deck = undefined;
    }

    onPointerDownDeck(deck) {
        this.pointer_down_card = undefined;
        this.pointer_down_deck = deck;
    }

    onPointerUpDeck(deck) {
        if (this.pointer_down_card != undefined) {
            this.returnCardToDeck(this.pointer_down_card, deck);
        } else if (this.pointer_down_deck != undefined) {
            this.drawCardFromDeck(deck);
        }

        this.pointer_down_card = undefined;
        this.pointer_down_deck = undefined;
    }

    returnCardToDeck(card, deck) {

        if (card.data.type == deck.card_type) {
            deck.add_card(card.index);
            card.resetPosition();
        }
    }

    drawCardFromDeck(deck) {
        var card_id = deck.draw_card();

        if (card_id != undefined) {
            var card = this.cards.filter(card => card.index == card_id)[0];
            card.moveTo(100, 100, true);
        }
    }

    getCardById(id) {
        return this.cards.filter(card => card.data.id == id)[0];
    }
}

</script>
</body>