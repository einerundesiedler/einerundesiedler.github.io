<meta charset="UTF-8"> 
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
<head>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.50.0/dist/phaser.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.2.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.2.1/firebase-database.js"></script>

<style>
    
	body {	
		margin: 0;
		padding: 0;
		background-color: #f1f1f1;
	}
</style>
</head>
<body>
<script>RELEASE=true;</script>
<script>VERSION="12/27/2020, 19:21:17";</script>

<script>
function array_remove_duplicates(value, index, self) {
  return self.indexOf(value) === index;
}

function shuffle_array(array) {
    var currentIndex = array.length, temporaryValue, randomIndex;
  
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
  
      // Pick a remaining element...
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex -= 1;
  
      // And swap it with the current element.
      temporaryValue = array[currentIndex];
      array[currentIndex] = array[randomIndex];
      array[randomIndex] = temporaryValue;
    }
  
    return array;
  }
</script>
<script>
class DB {
    constructor() {
        // firebase config 
        var firebaseConfig = {
            apiKey: "AIzaSyCsKZy0uardEJ9ptCUnWPiPBZPusp7aXy4",
            authDomain: "einerundesiedler-50542.firebaseapp.com",
            databaseURL: "https://einerundesiedler-50542-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "einerundesiedler-50542",
            storageBucket: "einerundesiedler-50542.appspot.com",
            messagingSenderId: "1037179221686",
            appId: "1:1037179221686:web:1b86c4acf11eac025c1817"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);

        // get realtime database references
        this.refCards = firebase.database().ref().child('cards');

    }    

    // serialize card data with initial position
    reset_card_positions(cards) {
        var data = {};
        for (var i = 0; i < cards.length; i++) {
            data[String(i)] = {
                x: Card.start_x,
                y: Card.start_y
            };
        }
        
        // upload to database
        this.refCards.set(data);
    }
    
    // upload new card position to database
    set_card_position(card_index, x, y) {
        this.refCards.child(String(card_index)).set({x: x, y:y});
    }

    // creates individual listener for each card position
    link_card_positions(gameLoop) {
        gameLoop.cards.forEach(card => {
            this.refCards.child(String(card.index)).on('value', (snapshot) => {
                var pos = snapshot.val();
                gameLoop.cards[card.index].on_pos_update_in_database(pos.x, pos.y);
            });
        });

    }

}


</script>
<script>
class Button {
    constructor(scene, x, y, text, onClick) {

        this.bg = scene.add.image(x, y, 'button').setInteractive();
        this.bg.on('pointerup', onClick);

        this.textfield = scene.add.text(x-60, y, text, { fontSize: '24px', fill: '#000' });
    }

    set text(val) {
        this.textfield.text = val;
    }
}
</script>
<script>

class Card{
    static hasDragListener = false;
    static start_x = -200;
    static start_y = -200;


    constructor(scene, card_data, index) {
        // short index for realtime database connection to save bandwidth 
        this.index = index;
        this.data = card_data;
        this.scene = scene;

        // ui components
        this.image = scene.add.image(Card.start_x, Card.start_y, card_data.src).setInteractive();
        this.image.setScale(0.33);

        // parent view pointer for drag listener resolving 
        this.image.view = this; 

        // set drag listeners only once
        scene.input.setDraggable(this.image);
        if (!Card.hasDragListener) {
            Card.hasDragListener = true;
            scene.input.on('drag',  (pointer, gameObject, dragX, dragY) => { gameObject.view.onDrag(dragX, dragY); });
            scene.input.on('dragend', (pointer, gameObject) => { gameObject.view.onDragEnd(); });
        }

    }

    moveTo(x, y, sync) {
        this.image.x = x;
        this.image.y = y;

        if (sync == true) {
            this.sync();
        }
    }

    onDrag(dragX, dragY) {
        this.moveTo(dragX, dragY);
    }

    onDragEnd() {
        this.sync();
    }

    sync() {
        this.scene.db.set_card_position(this.index, this.image.x, this.image.y);
    }

    on_pos_update_in_database(x, y) {
        this.moveTo(x, y);
    }
}



// creates card views and stores it in gameloop.cards
// links position to database
function create_cards_from_json(scene, json) {
    for(var i = 0; i < json.cards.length; i++) {
        var data = json.cards[i];
        var card = new Card(scene, data, i);

        // store in gameloop
        scene.main.cards.push(card);
    }

    // syncronize card position
    scene.db.link_card_positions(scene.main);
}
</script>
<script>


class CardDeck {
    constructor(card_back)  {
        this.cards = [];
        this.card_back = card_back;
        this.hover = false;
    }

    set_cards(cards) {
        this.cards = cards;
        this.shuffle();
    }

    add_to_scene(scene, x, y) {
        this.scene = scene;
        this.obj = scene.add.image(x, y, this.card_back).setInteractive();
        this.textfield = scene.add.text(x-60, y-10, "", { fontSize: '22px', fill: '#fff' });

        this.obj.setScale(0.5);
        
        this.obj.on('pointerup', () => this.onDeckClick(this)); 
        this.obj.on('pointerover', () => this.onPointerOver(this)); 
        this.obj.on('pointerout', () => this.onPointerOut(this)); 
    }

    onDeckClick() {
        this.scene.main.onDeckClick(this);  
    }

    onPointerOver() {
        this.hover = true;
        this.update();
    }

    onPointerOut() {
        this.hover = false;
        this.update();
    }

    update() {
        if (this.hover) {
            this.obj.setTint(0x555555);
        } else {
            this.obj.clearTint();
        }

        this.textfield.text = this.hover ? this.num_cards + " Karten" : "";
    }
    
    get num_cards() {
        return this.cards.length;
    }

    add_card(data) {
        this.cards.push(data);
    }

    remove_card(id) {
        this.cards = this.cards.filter(card => card.id != id);
    }

    shuffle() {   
        this.cards = shuffle_array(this.cards);
    }

    draw_card() {
        var card = this.cards.pop();
        this.update();
        return card;
    }
}

// call during scene.preload()
// loads all card images from json asset list
function load_card_images(scene, json) {
    var urls = json.cards.map(card => card.src).filter(array_remove_duplicates);
    urls = json.card_backs.concat(urls);

    urls.forEach(url => {
        scene.load.image(url, ASSET_PATH + "cards/" + url);
    });

}

function create_decks(scene) {
    var y_start = 450;

    scene.main.decks.events = new CardDeck("back_event.png");
    scene.main.decks.events.add_to_scene(scene, 100, y_start);
    
    scene.main.decks.cities = new CardDeck("back_city.png");
    scene.main.decks.cities.add_to_scene(scene, 250, y_start);
    
    scene.main.decks.roads = new CardDeck("back_road.png");
    scene.main.decks.roads.add_to_scene(scene, 400, y_start);

    scene.main.decks.villages = new CardDeck("back_village.png");
    scene.main.decks.villages.add_to_scene(scene, 550, y_start);

    scene.main.decks.environments = new CardDeck("back_environment.png");
    scene.main.decks.environments.add_to_scene(scene, 700, y_start);
    
    scene.main.decks.extensions = [];

    for(var i = 0; i < 5; i++) {
        scene.main.decks.extensions.push(new CardDeck("back_extension.png"));
        scene.main.decks.extensions[i].add_to_scene(scene, 850 + i * 150, y_start );
    }
}

function init_decks(gameLoop) {
    var cards = gameLoop.cards;

    gameLoop.decks.events.set_cards(cards.filter(card => card.data.type == "EVENT"));
    gameLoop.decks.cities.set_cards(cards.filter(card => card.data.type == "CITY"));
    gameLoop.decks.roads.set_cards(cards.filter(card => card.data.type == "ROAD"));
    gameLoop.decks.villages.set_cards(cards.filter(card => card.data.type == "VILLAGE"));
    gameLoop.decks.environments.set_cards(cards.filter(card => card.data.type == "ENVIRONMENT"));

    var card_extensions = shuffle_array(cards.filter(card => card.data.type == "EXTENSION"));
    var num_cards = Math.ceil(card_extensions.length / 5);

    for(var i = 0; i < 5; i++) {
        var cards = card_extensions.slice(i*num_cards, Math.min((i+1)*num_cards, card_extensions.length));
        gameLoop.decks.extensions[i].set_cards(cards);
    }

}
</script>
<script>
ASSET_PATH = !RELEASE ? "assets/" : "https://raw.githubusercontent.com/einerundesiedler/einerundesiedler.github.io/master/assets/";

var config = {
    type: Phaser.AUTO,
    width: 1920,
    height: 1080,
    backgroundColor: "#ffb",
    scene: {
        preload: preload,
        create: create,
        update: update,
        render: render
    }
};

var game = new Phaser.Game(config);

function preload ()
{
    this.db = new DB();

    this.load.once('load', (fileObj) => onLoaded(this, fileObj));
    this.load.json('cardlist', ASSET_PATH+'cardlist.json');

    this.load.image('button', ASSET_PATH+"ui/button.png");
}

function onLoaded(scene, fileObj) {
    
    switch(fileObj.key) {
        case "cardlist":
            load_card_images(scene, JSON.parse(fileObj.xhrLoader.response));
            break;
    } 
}


function create ()
{
    this.add.text(2, 2, 'version: ' + VERSION, { fontSize: '12px', fill: '#000' });

    // ------------------- GAME LOOP ----------------
    this.main = new GameLoop(this);
    
    // creates cards and links to database
    create_cards_from_json(this, this.cache.json.get('cardlist'));

    // create empty decks and link to database
    create_decks(this);
    



    // ------------------- UI ----------------
    this.ui = {};
    this.ui.btn_newgame = new Button(this, 650, 20, "new game", () => this.main.onNewGameClick());
    this.ui.btn_player = new Button(this, 800, 20, "join", () => this.main.onPlayerButtonClick());


}

function update ()
{
}


function render () 
{

}




class GameLoop {
    constructor(scene)  {
        this.scene = scene;
        this.playerID = 0;

        this.cards = [];
        this.decks = {};
    }

    onNewGameClick() {
        console.log("TODO: new game");

        // create card data from 
        init_decks(this);

        this.scene.db.reset_card_positions(this.cards);

        // --- RED SETUP
        this.getCardById("env_coal_red").moveTo(500, 120, true);
        this.getCardById("village_red_1").moveTo(600, 220, true);
        this.getCardById("env_brick_red").moveTo(500, 320, true);
        
        this.getCardById("env_gold_red").moveTo(700, 120, true);
        this.getCardById("road_red").moveTo(700, 220, true);
        this.getCardById("env_wheat_red").moveTo(700, 320, true);
        
        this.getCardById("env_wood_red").moveTo(900, 120, true);
        this.getCardById("village_red_2").moveTo(800, 220, true);
        this.getCardById("env_sheep_red").moveTo(900, 320, true);

        // --- BLACK SETUP
        this.getCardById("env_coal_black").moveTo(500, 580, true);
        this.getCardById("village_black_1").moveTo(600, 680, true);
        this.getCardById("env_brick_black").moveTo(500, 780, true);
        
        this.getCardById("env_gold_black").moveTo(700, 580, true);
        this.getCardById("road_black").moveTo(700, 680, true);
        this.getCardById("env_wheat_black").moveTo(700, 780, true);
        
        this.getCardById("env_wood_black").moveTo(900, 580, true);
        this.getCardById("village_black_2").moveTo(800, 680, true);
        this.getCardById("env_sheep_black").moveTo(900, 780, true);
    }

    onPlayerButtonClick() {
        this.playerID = this.playerID == 1 ? 2 : 1;
        this.scene.ui.btn_player.text = "player: " + this.playerID;
    }

    onDeckClick(deck) {
        console.log("deck clicked -> add card to player");
        deck.draw_card();
    }

    getCardById(id) {
        return this.cards.filter(card => card.data.id == id)[0];
    }
}

</script>
</body>